from collections import defaultdict, deque
from escaperoom.rooms.base import Room
from escaperoom import utils

class MalwareRoom(Room):
    name = "malware"

    def enter(self, state):
        return (
            "Dear student, you find yourself in the malware analysis lab.\n"
            "\n"
            "Item you can see: proc_tree.jsonl"
        )

    def inspect(self, item, state, tr):
        start_pid = None
        if ":" in item:
            left, right = item.split(":", 1)
            item = left
            try:
                start_pid = int(right)
            except Exception:
                start_pid = None

        if item != "proc_tree.jsonl":
            return "The only file here is 'proc_tree.jsonl'."

        steps = []
        steps.append("[MALWARE] reading data/proc_tree.jsonl ...")

        records = list(utils.jsonl_iter("data/proc_tree.jsonl"))
        if not records:
            return "[MALWARE] couldn't read any process records."

        children = defaultdict(list)
        cmd_by = {}
        all_pids = set()
        all_children = set()
        roots_by_ppid0 = set()

        for r in records:
            pid = r.get("pid")
            ppid = r.get("ppid")
            cmd = r.get("cmd", "")
            if not isinstance(pid, int) or not isinstance(ppid, int):
                continue
            cmd_by[pid] = cmd
            all_pids.add(pid)
            all_children.add(pid)
            children[ppid].append(pid)
            if ppid == 0:
                roots_by_ppid0.add(pid)

        # choose a start
        if start_pid is None:
            if roots_by_ppid0:
                start_pid = sorted(roots_by_ppid0)[0]
            else:
                possible_roots = set(children.keys()) - all_children
                if possible_roots:
                    start_pid = sorted(possible_roots)[0]
                else:
                    start_pid = sorted(all_pids)[0]
        steps.append(f"[MALWARE] start pid -> {start_pid}")

        target_cmd = None
        target_pid = None
        parent = {}
        visited = set()
        q = deque([start_pid])
        visited.add(start_pid)

        steps.append("[MALWARE] bfs over children[] until a cmd contains curl/scp")
        while q:
            cur = q.popleft()
            c = cmd_by.get(cur, "")
            if utils.is_exfil_command(c):
                target_cmd = c
                target_pid = cur
                break
            for nxt in children.get(cur, []):
                if nxt not in visited:
                    visited.add(nxt)
                    parent[nxt] = cur
                    q.append(nxt)

        if target_pid is None:
            return "[MALWARE] no curl/scp command found."

        # reconstruct path
        path = [target_pid]
        while path[-1] in parent:
            path.append(parent[path[-1]])
        path.reverse()

        token = str(target_pid)
        state.tokens["PID"] = token

        tr.log(f"TOKEN[PID]={token}")
        tr.log(f"EVIDENCE[PID].PATH=[{ '->'.join(str(x) for x in path) }]")
        tr.log(f'EVIDENCE[PID].CMD="{target_cmd}"')

        steps.append(f"[MALWARE] path found -> {'->'.join(str(x) for x in path)}")
        steps.append(f"[MALWARE] terminal command -> {target_cmd}")
        steps.append(f"[MALWARE] token (terminal pid) -> {token}")
        return "\n".join(steps)

    def hint(self, state):
        return (
            "Try: inspect proc_tree.jsonl\n"
            "We build children map and run BFS from a likely root until a cmd contains curl or scp.\n"
            "Token is the terminal pid on that path."
        )